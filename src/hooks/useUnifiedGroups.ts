import { useState, useRef, useEffect } from 'react';
import { useQuery, useQueryClient } from '@tanstack/react-query';
import { useAuth } from '@/contexts/AuthContext';
import { useAnalytics } from '@/hooks/useAnalytics';
import { GeolocationService, LocationData } from '@/services/geolocation';
import { GroupGeolocationService } from '@/services/groupGeolocation';
import { UnifiedGroupService } from '@/services/unifiedGroupService';
import { supabase } from '@/integrations/supabase/client';
// Nettoyage g√©r√© automatiquement par cleanup-groups edge function
import { useActivityHeartbeat } from '@/hooks/useActivityHeartbeat';
import { GROUP_CONSTANTS } from '@/constants/groupConstants';
import { ErrorHandler } from '@/utils/errorHandling';
import { showUniqueToast } from '@/utils/toastUtils';

import { CoordinateValidator } from '@/utils/coordinateValidation';
import { toast } from '@/hooks/use-toast';
import type { Group } from '@/types/database';
import type { GroupMember } from '@/types/groups';

export const useUnifiedGroups = () => {
  const { user } = useAuth();
  const { trackGroupCreate, trackGroupJoin } = useAnalytics();
  const queryClient = useQueryClient();
  const [loading, setLoading] = useState(false);
  const [userLocation, setUserLocation] = useState<LocationData | null>(null);
  const [groupMembers, setGroupMembers] = useState<GroupMember[]>([]);
  
  // ‚úÖ CORRECTION #3 : Protection anti-spam pour triggers de bar
  const processedTriggers = useRef(new Set<string>());
  
  const isGettingLocation = useRef(false);
  const locationPromise = useRef<Promise<LocationData> | null>(null);
  const lastLocationTime = useRef<number>(0);

  // Cache de localisation simplifi√©
  const getUserLocation = async (forceRefresh = false): Promise<LocationData | null> => {
    const now = Date.now();
    const locationCacheTime = 15 * 60 * 1000; // 15 minutes
    
    if (!forceRefresh && userLocation && (now - lastLocationTime.current) < locationCacheTime) {
      return userLocation;
    }

    if (isGettingLocation.current && locationPromise.current) {
      return locationPromise.current;
    }

    isGettingLocation.current = true;
    locationPromise.current = GeolocationService.getCurrentLocation()
      .then((location) => {
        setUserLocation(location);
        lastLocationTime.current = now;
        showUniqueToast(
          `Position d√©tect√©e: ${location.locationName}`,
          "üìç Position actualis√©e"
        );
        return location;
      })
      .catch((error) => {
        ErrorHandler.logError('GEOLOCATION', error);
        showUniqueToast(
          'G√©olocalisation indisponible - mode universel activ√©.',
          "üìç G√©olocalisation indisponible"
        );
        return null;
      })
      .finally(() => {
        isGettingLocation.current = false;
        locationPromise.current = null;
      });

    return locationPromise.current;
  };

  // R√©cup√©ration simplifi√©e des groupes
  const fetchUserGroups = async (): Promise<Group[]> => {
    if (!user) return [];

    try {
      const allParticipations = await UnifiedGroupService.getUserParticipations(user.id);
      const validGroups = allParticipations.map(p => p.groups).filter(Boolean);

      if (validGroups.length > 0) {
        await UnifiedGroupService.updateUserLastSeen(validGroups[0].id, user.id);
        const members = await UnifiedGroupService.getGroupMembers(validGroups[0].id);
        setGroupMembers(members);
      } else {
        setGroupMembers([]);
      }

      return validGroups;
    } catch (error) {
      ErrorHandler.logError('UNIFIED_FETCH_USER_GROUPS', error);
      return [];
    }
  };

  const { 
    data: userGroups = [], 
    isLoading: groupsLoading,
    refetch: refetchGroups 
  } = useQuery({
    queryKey: ['unifiedUserGroups', user?.id],
    queryFn: fetchUserGroups,
    enabled: !!user,
    refetchInterval: 10 * 60 * 1000, // ‚úÖ REALTIME: Polling 10 min (fallback s√©curit√©)
    staleTime: 5 * 60 * 1000, // ‚úÖ REALTIME: Cache 5 min (√©vite refetchs inutiles)
    refetchOnMount: 'always',
    refetchOnWindowFocus: false, // ‚úÖ REALTIME: Pas de refetch brutal (Realtime g√®re)
  });

  // Battement de c≈ìur simplifi√© - 1 heure (align√© avec GROUP_CONSTANTS.HEARTBEAT_INTERVAL)
  const activeGroupId = userGroups.length > 0 ? userGroups[0].id : null;
  const { isActive: isHeartbeatActive } = useActivityHeartbeat({
    groupId: activeGroupId,
    enabled: !!activeGroupId,
    intervalMs: GROUP_CONSTANTS.HEARTBEAT_INTERVAL // ‚úÖ Utilise la constante (1h)
  });

  // ‚úÖ CORRECTION #1 : D√©tection des triggers existants au montage
  const checkExistingTriggers = async (groupId: string) => {
    if (!user) return;
    
    console.log('üîç [TRIGGER MOUNT] V√©rification triggers existants pour groupe:', groupId);
    
    try {
      // Chercher les triggers AUTO_BAR_ASSIGNMENT_TRIGGER cr√©√©s il y a moins de 5 minutes
      const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000).toISOString();
      
      const { data: triggers, error: triggerError } = await supabase
        .from('group_messages')
        .select('id, group_id, created_at')
        .eq('group_id', groupId)
        .eq('is_system', true)
        .eq('message', 'AUTO_BAR_ASSIGNMENT_TRIGGER')
        .gte('created_at', fiveMinutesAgo)
        .order('created_at', { ascending: false })
        .limit(1);
      
      console.log('üîç [TRIGGER MOUNT] Triggers trouv√©s:', triggers?.length || 0);
      
      if (triggerError) {
        console.error('‚ùå [TRIGGER MOUNT] Erreur recherche triggers:', triggerError);
        return;
      }
      
      if (!triggers || triggers.length === 0) {
        console.log('‚úÖ [TRIGGER MOUNT] Aucun trigger en attente');
        return;
      }
      
      const trigger = triggers[0];
      
      // V√©rifier si d√©j√† trait√©
      if (processedTriggers.current.has(trigger.id)) {
        console.log('‚è≠Ô∏è [TRIGGER MOUNT] Trigger d√©j√† trait√©:', trigger.id);
        return;
      }
      
      // V√©rifier si le groupe a d√©j√† un bar assign√©
      const { data: groupData, error: groupError } = await supabase
        .from('groups')
        .select('bar_name, bar_place_id, latitude, longitude')
        .eq('id', groupId)
        .single();
      
      if (groupError) {
        console.error('‚ùå [TRIGGER MOUNT] Erreur fetch groupe:', groupError);
        return;
      }
      
      if (groupData?.bar_place_id) {
        console.log('‚úÖ [TRIGGER MOUNT] Bar d√©j√† assign√©:', groupData.bar_name);
        processedTriggers.current.add(trigger.id);
        return;
      }
      
      if (!groupData?.latitude || !groupData?.longitude) {
        console.error('‚ùå [TRIGGER MOUNT] Coordonn√©es manquantes pour le groupe');
        return;
      }
      
      // Marquer comme trait√© AVANT l'appel pour √©viter les doublons
      processedTriggers.current.add(trigger.id);
      
      console.log('üéØ [TRIGGER MOUNT] Appel edge function pour trigger:', trigger.id);
      
      // Appeler l'edge function
      const { data, error: invokeError } = await supabase.functions.invoke('simple-auto-assign-bar', {
        body: {
          group_id: groupId,
          latitude: groupData.latitude,
          longitude: groupData.longitude
        }
      });
      
      if (invokeError) {
        console.error('‚ùå [TRIGGER MOUNT] Erreur invocation edge function:', invokeError);
        processedTriggers.current.delete(trigger.id); // Retirer en cas d'√©chec pour r√©essayer
      } else {
        console.log('‚úÖ [TRIGGER MOUNT] Edge function appel√©e avec succ√®s:', data);
      }
      
    } catch (error) {
      console.error('‚ùå [TRIGGER MOUNT] Erreur globale:', error);
    }
  };

  // ‚úÖ CORRECTION #1 : useEffect pour v√©rifier les triggers au montage
  useEffect(() => {
    if (activeGroupId && user) {
      console.log('üöÄ [TRIGGER MOUNT] Montage - v√©rification triggers...');
      checkExistingTriggers(activeGroupId);
    }
  }, [activeGroupId, user?.id]);

  // üåç SOUSCRIPTION REALTIME GLOBALE : D√©tection instantan√©e des triggers (ind√©pendante de activeGroupId)
  useEffect(() => {
    if (!user) return;
    
    console.log('üåç [REALTIME GLOBAL] D√©marrage souscription globale pour user:', user.id);
    
    const globalChannel = supabase
      .channel(`user-triggers-${user.id}`)
      .on(
        'postgres_changes',
        {
          event: 'INSERT',
          schema: 'public',
          table: 'group_messages',
          // Pas de filtre group_id ‚Üí √©coute TOUS les messages syst√®me
        },
        (payload) => {
          const message = payload.new;
          
          console.log('üåç [REALTIME GLOBAL] Message syst√®me re√ßu:', {
            group_id: message?.group_id,
            is_system: message?.is_system,
            message_type: message?.message
          });
          
          // Si c'est un trigger d'attribution de bar
          if (message?.is_system && message?.message === 'AUTO_BAR_ASSIGNMENT_TRIGGER') {
            console.log('üéØ [REALTIME GLOBAL] ‚úÖ Trigger AUTO_BAR_ASSIGNMENT d√©tect√©!');
            
            const triggerGroupId = message.group_id;
            
            // V√©rifier si l'utilisateur est dans ce groupe
            supabase
              .from('group_participants')
              .select('id')
              .eq('group_id', triggerGroupId)
              .eq('user_id', user.id)
              .eq('status', 'confirmed')
              .maybeSingle()
              .then(({ data }) => {
                if (!data) {
                  console.log('‚è≠Ô∏è [REALTIME GLOBAL] User pas dans ce groupe, ignore');
                  return;
                }
                
                console.log('‚úÖ [REALTIME GLOBAL] User confirm√© dans le groupe');
                
                // Protection anti-spam
                if (processedTriggers.current.has(message.id)) {
                  console.log('‚è≠Ô∏è [REALTIME GLOBAL] Trigger d√©j√† trait√©, ignore:', message.id);
                  return;
                }
                
                processedTriggers.current.add(message.id);
                
                // R√©cup√©rer les coordonn√©es du groupe et appeler l'edge function
                supabase
                  .from('groups')
                  .select('latitude, longitude, bar_place_id')
                  .eq('id', triggerGroupId)
                  .single()
                  .then(({ data: groupData, error }) => {
                    if (error || !groupData) {
                      console.error('‚ùå [REALTIME GLOBAL] Erreur fetch groupe:', error);
                      processedTriggers.current.delete(message.id);
                      return;
                    }
                    
                    if (groupData.bar_place_id) {
                      console.log('‚è≠Ô∏è [REALTIME GLOBAL] Bar d√©j√† assign√©, ignore');
                      return;
                    }
                    
                    if (!groupData.latitude || !groupData.longitude) {
                      console.error('‚ùå [REALTIME GLOBAL] Coordonn√©es manquantes');
                      processedTriggers.current.delete(message.id);
                      return;
                    }
                    
                    console.log('üöÄ [REALTIME GLOBAL] Invocation edge function...');
                    supabase.functions.invoke('simple-auto-assign-bar', {
                      body: {
                        group_id: triggerGroupId,
                        latitude: groupData.latitude,
                        longitude: groupData.longitude
                      }
                    }).then(({ data, error }) => {
                      if (error) {
                        console.error('‚ùå [REALTIME GLOBAL] Erreur edge function:', error);
                        processedTriggers.current.delete(message.id);
                      } else {
                        console.log('‚úÖ [REALTIME GLOBAL] Edge function OK:', data);
                      }
                    });
                  });
              });
          }
        }
      )
      .subscribe((status) => {
        console.log('üåç [REALTIME GLOBAL] Statut souscription:', status);
      });
    
    return () => {
      console.log('üåç [REALTIME GLOBAL] Nettoyage souscription globale');
      supabase.removeChannel(globalChannel);
    };
  }, [user?.id]);

  // ‚úÖ REALTIME LOCAL: Souscription aux changements de groupe ET participants (fallback s√©curit√©)
  useEffect(() => {
    if (!activeGroupId || !user) {
      console.log('üîÑ [REALTIME] ‚ùå Pas de souscription:', { activeGroupId, user: !!user });
      return;
    }

    console.log('üîÑ [REALTIME] ‚úÖ Souscription au groupe:', activeGroupId);
    console.log('üîÑ [REALTIME] User ID:', user.id);

    // Canal unique pour √©couter √† la fois groups et group_participants
    const channel = supabase
      .channel(`group-updates-${activeGroupId}`)
      // √âcouter les changements sur la table groups
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'groups',
          filter: `id=eq.${activeGroupId}`,
        },
        (payload) => {
          console.log('üîÑ [REALTIME] Groupe modifi√©:', payload);
          
          // ‚úÖ Mise √† jour INSTANTAN√âE du cache (synchrone)
          if (payload.eventType === 'UPDATE' && payload.new) {
            queryClient.setQueryData(['unifiedUserGroups', user.id], (oldData: Group[] | undefined) => {
              if (!oldData) return oldData;
              return oldData.map(group => 
                group.id === activeGroupId 
                  ? { ...group, ...payload.new }
                  : group
              );
            });
          } else if (payload.eventType === 'DELETE') {
            queryClient.setQueryData(['unifiedUserGroups', user.id], (oldData: Group[] | undefined) => {
              if (!oldData) return oldData;
              return oldData.filter(group => group.id !== activeGroupId);
            });
          }
        }
      )
      // √âcouter les changements sur la table group_participants
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'group_participants',
          filter: `group_id=eq.${activeGroupId}`,
        },
        (payload) => {
          console.log('üîÑ [REALTIME] Participant modifi√©:', payload);
          
          // ‚úÖ Mise √† jour INSTANTAN√âE du compteur (synchrone)
          if (payload.eventType === 'INSERT') {
            queryClient.setQueryData(['unifiedUserGroups', user.id], (oldData: Group[] | undefined) => {
              if (!oldData) return oldData;
              return oldData.map(group => 
                group.id === activeGroupId 
                  ? { ...group, current_participants: group.current_participants + 1 }
                  : group
              );
            });
            window.dispatchEvent(new CustomEvent('group:member-joined'));
            showUniqueToast('Un nouveau membre a rejoint le groupe !', '‚ú® Nouveau membre');
          } else if (payload.eventType === 'DELETE') {
            queryClient.setQueryData(['unifiedUserGroups', user.id], (oldData: Group[] | undefined) => {
              if (!oldData) return oldData;
              return oldData.map(group => 
                group.id === activeGroupId 
                  ? { ...group, current_participants: Math.max(0, group.current_participants - 1) }
                  : group
              );
            });
          }
          
          // ‚úÖ Refetch membres en ARRI√àRE-PLAN (sans bloquer UI)
          UnifiedGroupService.getGroupMembers(activeGroupId)
            .then(members => {
              setGroupMembers(members);
            })
            .catch(error => {
              console.error('Erreur refetch membres:', error);
            });
        }
      )
      // ‚úÖ CORRECTION #2 : √âcouter les triggers d'attribution de bar (SYNCHRONE avec .then())
      .on(
        'postgres_changes',
        {
          event: 'INSERT',
          schema: 'public',
          table: 'group_messages',
          filter: `group_id=eq.${activeGroupId}`,
        },
        (payload) => {
          console.log('üîî [TRIGGER REALTIME] Message re√ßu:', {
            eventType: payload.eventType,
            new: payload.new,
            timestamp: new Date().toISOString()
          });
          
          // ‚úÖ CORRECTION #5 : V√©rification payload.new
          if (!payload.new) {
            console.warn('‚ö†Ô∏è [TRIGGER REALTIME] payload.new est undefined');
            return;
          }
          
          const message = payload.new;
          
          console.log('üì® [TRIGGER REALTIME] Contenu message:', {
            id: message.id,
            is_system: message.is_system,
            message: message.message,
            group_id: message.group_id
          });
          
          // Si c'est un trigger d'attribution de bar
          if (message.is_system && message.message === 'AUTO_BAR_ASSIGNMENT_TRIGGER') {
            console.log('üéØ [TRIGGER REALTIME] ‚úÖ Trigger AUTO_BAR_ASSIGNMENT d√©tect√©!');
            
            // ‚úÖ CORRECTION #3 : Protection anti-spam
            if (processedTriggers.current.has(message.id)) {
              console.log('‚è≠Ô∏è [TRIGGER REALTIME] Trigger d√©j√† trait√©, ignore:', message.id);
              return;
            }
            
            // Marquer comme trait√© IMM√âDIATEMENT
            processedTriggers.current.add(message.id);
            console.log('‚úÖ [TRIGGER REALTIME] Marqu√© comme trait√©:', message.id);
            
            // ‚úÖ CORRECTION #2 : Cha√Æne .then() au lieu de async/await
            console.log('üì° [TRIGGER REALTIME] R√©cup√©ration coordonn√©es groupe...');
            
            const invokeBarAssignment = async () => {
              try {
                const { data: groupData, error: fetchError } = await supabase
                  .from('groups')
                  .select('latitude, longitude, bar_place_id')
                  .eq('id', activeGroupId)
                  .single();
                
                if (fetchError) {
                  console.error('‚ùå [TRIGGER REALTIME] Erreur fetch groupe:', fetchError);
                  processedTriggers.current.delete(message.id);
                  return;
                }
                
                console.log('üìç [TRIGGER REALTIME] Donn√©es groupe:', {
                  latitude: groupData?.latitude,
                  longitude: groupData?.longitude,
                  bar_place_id: groupData?.bar_place_id
                });
                
                if (groupData?.bar_place_id) {
                  console.log('‚è≠Ô∏è [TRIGGER REALTIME] Bar d√©j√† assign√©, ignore');
                  return;
                }
                
                if (!groupData?.latitude || !groupData?.longitude) {
                  console.error('‚ùå [TRIGGER REALTIME] Coordonn√©es manquantes');
                  processedTriggers.current.delete(message.id);
                  return;
                }
                
                console.log('üöÄ [TRIGGER REALTIME] Invocation edge function simple-auto-assign-bar...');
                const { data, error } = await supabase.functions.invoke('simple-auto-assign-bar', {
                  body: {
                    group_id: activeGroupId,
                    latitude: groupData.latitude,
                    longitude: groupData.longitude
                  }
                });
                
                if (error) {
                  console.error('‚ùå [TRIGGER REALTIME] Erreur invocation edge function:', error);
                  processedTriggers.current.delete(message.id);
                } else {
                  console.log('‚úÖ [TRIGGER REALTIME] Edge function appel√©e avec succ√®s:', data);
                }
              } catch (error) {
                console.error('‚ùå [TRIGGER REALTIME] Erreur globale:', error);
                processedTriggers.current.delete(message.id);
              }
            };
            
            // Appeler sans bloquer le callback Realtime
            invokeBarAssignment();
          } else {
            console.log('‚ÑπÔ∏è [TRIGGER REALTIME] Message non-trigger:', {
              is_system: message.is_system,
              message: message.message?.substring(0, 50)
            });
          }
        }
      )
      .subscribe();

    return () => {
      console.log('üîÑ [REALTIME] D√©sinscription du groupe:', activeGroupId);
      supabase.removeChannel(channel);
    };
  }, [activeGroupId, user?.id]); // ‚úÖ CORRECTION #4 : D√©pendances correctes (sans queryClient)

  // Fonction de cr√©ation de groupe avec rate limiting
  const joinRandomGroup = async (): Promise<boolean> => {
    if (!user) {
      toast({ 
        title: 'Erreur', 
        description: 'Vous devez √™tre connect√© pour rejoindre un groupe.', 
        variant: 'destructive' 
      });
      return false;
    }

    if (loading) {
      return false;
    }


    const isAuthenticated = await UnifiedGroupService.verifyUserAuthentication();
    if (!isAuthenticated) {
      toast({ 
        title: 'Session expir√©e', 
        description: 'Veuillez vous reconnecter.', 
        variant: 'destructive' 
      });
      return false;
    }

    setLoading(true);
    
    try {
      console.log('üéØ D√âBUT - Recherche/Cr√©ation de groupe avec nouveau syst√®me');
      
      // 1. G√©olocalisation fra√Æche
      console.log('üìç G√©olocalisation...');
      const location = await getUserLocation(true);
      if (!location) {
        toast({ 
          title: 'G√©olocalisation requise', 
          description: 'Votre position est n√©cessaire pour cr√©er un groupe.', 
          variant: 'destructive' 
        });
        return false;
      }

      // 2. V√©rification UNIFI√âE des participations existantes avec nouveau syst√®me
      console.log('üîç V√©rification des participations avec nouveau syst√®me...');
      const allParticipations = await UnifiedGroupService.getUserParticipations(user.id);
      
      if (allParticipations.length > 0) {
        console.log('‚ö†Ô∏è Participation active d√©tect√©e avec nouveau syst√®me');
        toast({ 
          title: 'D√©j√† dans un groupe', 
          description: 'Vous √™tes d√©j√† dans un groupe actif.', 
          variant: 'destructive' 
        });
        return false;
      }

      // 3. Recherche de groupe compatible
      console.log('üåç Recherche de groupe compatible...');
      const targetGroup = await GroupGeolocationService.findCompatibleGroup(location);

      if (!targetGroup) {
        // 4. Cr√©ation de groupe neuf
        console.log('üÜï Cr√©ation d\'un groupe neuf...');
        const newGroup = await UnifiedGroupService.createGroup(location, user.id);
        
        if (newGroup) {
          trackGroupCreate(newGroup.id);
          queryClient.invalidateQueries({ queryKey: ['unifiedUserGroups'] });
          setTimeout(() => refetchGroups(), 500);
          
          toast({ 
            title: 'üéâ Nouveau groupe cr√©√©', 
            description: `Groupe cr√©√© √† ${location.locationName}. Vous pouvez maintenant fermer l'app !`, 
          });
          return true;
        }
        return false;
      } else {
        // 5. Rejoindre groupe existant
        console.log('üîó Rejoindre groupe compatible existant...');
        const success = await UnifiedGroupService.joinGroup(targetGroup.id, user.id, location);
        
        if (success) {
          trackGroupJoin(targetGroup.id);
          queryClient.invalidateQueries({ queryKey: ['unifiedUserGroups'] });
          setTimeout(() => refetchGroups(), 500);
          
          toast({ 
            title: '‚úÖ Groupe rejoint', 
            description: `Vous avez rejoint un groupe √† ${location.locationName}. Vous pouvez fermer l'app !`, 
          });
        }
        return success;
      }
    } catch (error) {
      ErrorHandler.logError('JOIN_RANDOM_GROUP', error);
      const appError = ErrorHandler.handleGenericError(error as Error);
      ErrorHandler.showErrorToast(appError);
      return false;
    } finally {
      setLoading(false);
    }
  };

  // Fonction de sortie avec nettoyage LOCAL seulement
  const leaveGroup = async (groupId: string): Promise<void> => {
    if (!user || loading) {
      return;
    }


    setLoading(true);
    try {
      console.log('üö™ [UNIFIED] Sortie de groupe...');
      
      // 1. Nettoyage imm√©diat de l'√©tat local
      setGroupMembers([]);
      queryClient.setQueryData(['unifiedUserGroups', user.id], []);

      // 2. Sortie du groupe
      const success = await UnifiedGroupService.leaveGroup(groupId, user.id);
      
      if (success) {
        // 3. Invalidation contr√¥l√©e du cache
        queryClient.invalidateQueries({ queryKey: ['unifiedUserGroups'] });
        
        toast({ 
          title: '‚úÖ Groupe quitt√©', 
          description: 'Vous avez quitt√© le groupe avec succ√®s.' 
        });
        
        // 4. Refetch apr√®s d√©lai
        setTimeout(() => refetchGroups(), 1000);
      }
    } catch (error) {
      ErrorHandler.logError('LEAVE_GROUP', error);
      const appError = ErrorHandler.handleGenericError(error as Error);
      ErrorHandler.showErrorToast(appError);
    } finally {
      setLoading(false);
    }
  };

  return {
    userGroups,
    groupMembers,
    loading: loading || groupsLoading,
    userLocation,
    joinRandomGroup,
    leaveGroup,
    fetchUserGroups,
    refetchGroups,
    // Debug info
    isHeartbeatActive,
    activeGroupId
  };
};
