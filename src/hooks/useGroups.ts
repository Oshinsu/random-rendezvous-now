
import { useState, useEffect, useCallback, useRef } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from '@/contexts/AuthContext';
import { Group } from '@/types/database';
import { toast } from '@/hooks/use-toast';
import { GeolocationService, LocationData } from '@/services/geolocation';

// Liste des bars parisiens pour la s√©lection al√©atoire
const PARIS_BARS = [
  { name: "Le Procope", address: "13 Rue de l'Ancienne Com√©die, 75006 Paris", lat: 48.8534, lng: 2.3371 },
  { name: "Harry's Bar", address: "5 Rue Daunou, 75002 Paris", lat: 48.8699, lng: 2.3314 },
  { name: "Le Mary Celeste", address: "1 Rue Commines, 75003 Paris", lat: 48.8596, lng: 2.3639 },
  { name: "Candelaria", address: "52 Rue de Saintonge, 75003 Paris", lat: 48.8625, lng: 2.3639 },
  { name: "Little Red Door", address: "60 Rue Charlot, 75003 Paris", lat: 48.8630, lng: 2.3652 },
  { name: "Le Syndicat", address: "51 Rue du Faubourg Saint-Antoine, 75011 Paris", lat: 48.8532, lng: 2.3724 },
  { name: "Hemingway Bar", address: "15 Place Vend√¥me, 75001 Paris", lat: 48.8670, lng: 2.3292 },
  { name: "Le Bar du Plaza", address: "25 Avenue Montaigne, 75008 Paris", lat: 48.8665, lng: 2.3065 },
  { name: "Moonshiner", address: "5 Rue Sedaine, 75011 Paris", lat: 48.8553, lng: 2.3714 },
  { name: "Glass", address: "7 Rue Frochot, 75009 Paris", lat: 48.8823, lng: 2.3367 }
];

const getRandomBar = (userLat?: number, userLng?: number) => {
  if (userLat && userLng) {
    // Trier les bars par distance si on a la position utilisateur
    const barsWithDistance = PARIS_BARS.map(bar => ({
      ...bar,
      distance: GeolocationService.calculateDistance(userLat, userLng, bar.lat, bar.lng)
    })).sort((a, b) => a.distance - b.distance);
    
    // Prendre un des 5 bars les plus proches au hasard
    const nearestBars = barsWithDistance.slice(0, 5);
    const randomIndex = Math.floor(Math.random() * nearestBars.length);
    return nearestBars[randomIndex];
  }
  
  // Fallback: bar compl√®tement al√©atoire
  const randomIndex = Math.floor(Math.random() * PARIS_BARS.length);
  return PARIS_BARS[randomIndex];
};

// Global channel reference to prevent multiple subscriptions
let globalChannel: any = null;
let subscriberCount = 0;

export const useGroups = () => {
  const { user } = useAuth();
  const [groups, setGroups] = useState<Group[]>([]);
  const [userGroups, setUserGroups] = useState<Group[]>([]);
  const [loading, setLoading] = useState(false);
  const [userLocation, setUserLocation] = useState<LocationData | null>(null);
  const fetchingRef = useRef(false);
  const lastFetchRef = useRef<number>(0);

  // Obtenir la g√©olocalisation de l'utilisateur au montage
  useEffect(() => {
    const getUserLocation = async () => {
      try {
        const location = await GeolocationService.getCurrentLocation();
        setUserLocation(location);
        console.log('üìç Position utilisateur obtenue:', location);
      } catch (error) {
        console.warn('‚ö†Ô∏è Impossible d\'obtenir la position:', error);
        // On continue sans g√©olocalisation
      }
    };

    getUserLocation();
  }, []);

  const fetchUserGroups = useCallback(async () => {
    if (!user || fetchingRef.current) {
      console.log('üö´ Fetch bloqu√© - utilisateur:', !!user, 'en cours:', fetchingRef.current);
      return;
    }
    
    // √âviter les appels trop fr√©quents
    const now = Date.now();
    if (now - lastFetchRef.current < 1000) {
      console.log('üö´ Fetch trop fr√©quent, ignor√©');
      return;
    }
    
    fetchingRef.current = true;
    lastFetchRef.current = now;
    setLoading(true);
    
    try {
      console.log('üîÑ R√©cup√©ration des groupes pour:', user.id);
      
      const { data: participations, error: participationError } = await supabase
        .from('group_participants')
        .select('group_id')
        .eq('user_id', user.id)
        .eq('status', 'confirmed');

      if (participationError) {
        console.error('‚ùå Erreur participations:', participationError);
        throw participationError;
      }

      console.log('‚úÖ Participations trouv√©es:', participations?.length || 0);

      if (!participations || participations.length === 0) {
        setUserGroups([]);
        return;
      }

      const groupIds = participations.map(p => p.group_id);
      
      const { data: groupsData, error: groupsError } = await supabase
        .from('groups')
        .select('*')
        .in('id', groupIds)
        .order('created_at', { ascending: false });

      if (groupsError) {
        console.error('‚ùå Erreur groupes:', groupsError);
        throw groupsError;
      }

      console.log('‚úÖ Groupes r√©cup√©r√©s:', groupsData?.length || 0);

      // V√©rifier et corriger le comptage des participants pour chaque groupe
      if (groupsData && groupsData.length > 0) {
        for (const group of groupsData) {
          await syncGroupParticipantCount(group.id);
        }
        
        // Re-fetch les groupes apr√®s correction
        const { data: correctedGroups } = await supabase
          .from('groups')
          .select('*')
          .in('id', groupIds)
          .order('created_at', { ascending: false });
        
        setUserGroups((correctedGroups || []) as Group[]);
      } else {
        setUserGroups([]);
      }
    } catch (error) {
      console.error('‚ùå Erreur fetchUserGroups:', error);
      toast({ 
        title: 'Erreur', 
        description: 'Impossible de r√©cup√©rer vos groupes.', 
        variant: 'destructive' 
      });
    } finally {
      setLoading(false);
      fetchingRef.current = false;
    }
  }, [user]);

  // Nouvelle fonction pour synchroniser le comptage des participants
  const syncGroupParticipantCount = async (groupId: string) => {
    try {
      console.log('üîÑ Synchronisation du comptage pour le groupe:', groupId);
      
      // Compter les vrais participants
      const { data: realParticipants, error: countError } = await supabase
        .from('group_participants')
        .select('id')
        .eq('group_id', groupId)
        .eq('status', 'confirmed');

      if (countError) {
        console.error('‚ùå Erreur de comptage:', countError);
        return;
      }

      const realCount = realParticipants?.length || 0;
      console.log('üìä Nombre r√©el de participants:', realCount);

      // Mettre √† jour le groupe avec le bon comptage
      const { error: updateError } = await supabase
        .from('groups')
        .update({ current_participants: realCount })
        .eq('id', groupId);

      if (updateError) {
        console.error('‚ùå Erreur de mise √† jour:', updateError);
      } else {
        console.log('‚úÖ Comptage synchronis√©:', realCount);
      }
    } catch (error) {
      console.error('‚ùå Erreur de synchronisation:', error);
    }
  };

  const findCompatibleGroup = async (userLocation: LocationData) => {
    try {
      console.log('üîç Recherche de groupes compatibles pr√®s de:', userLocation.locationName);
      
      // Rechercher des groupes en attente dans un rayon g√©ographique
      const { data: nearbyGroups, error } = await supabase
        .from('groups')
        .select('*')
        .eq('status', 'waiting')
        .lt('current_participants', 5)
        .not('latitude', 'is', null)
        .not('longitude', 'is', null);

      if (error) {
        console.error('‚ùå Erreur recherche groupes:', error);
        throw error;
      }

      if (!nearbyGroups || nearbyGroups.length === 0) {
        console.log('üìç Aucun groupe g√©olocalis√© trouv√©');
        return null;
      }

      // Filtrer par distance (rayon de 5km par d√©faut)
      const compatibleGroups = nearbyGroups.filter(group => {
        if (!group.latitude || !group.longitude) return false;
        
        const distance = GeolocationService.calculateDistance(
          userLocation.latitude,
          userLocation.longitude,
          group.latitude,
          group.longitude
        );
        
        const searchRadius = group.search_radius || 5000; // 5km par d√©faut
        return distance <= searchRadius;
      });

      if (compatibleGroups.length === 0) {
        console.log('üìç Aucun groupe dans le rayon de recherche');
        return null;
      }

      // Trier par distance et prendre le plus proche
      compatibleGroups.sort((a, b) => {
        const distanceA = GeolocationService.calculateDistance(
          userLocation.latitude, userLocation.longitude,
          a.latitude!, a.longitude!
        );
        const distanceB = GeolocationService.calculateDistance(
          userLocation.latitude, userLocation.longitude,
          b.latitude!, b.longitude!
        );
        return distanceA - distanceB;
      });

      const selectedGroup = compatibleGroups[0];
      const distance = GeolocationService.calculateDistance(
        userLocation.latitude, userLocation.longitude,
        selectedGroup.latitude!, selectedGroup.longitude!
      );

      console.log('‚úÖ Groupe compatible trouv√© √†', GeolocationService.formatDistance(distance));
      return selectedGroup as Group;
      
    } catch (error) {
      console.error('‚ùå Erreur recherche groupe compatible:', error);
      return null;
    }
  };

  const joinRandomGroup = async () => {
    if (!user) {
      toast({ 
        title: 'Erreur', 
        description: 'Vous devez √™tre connect√© pour rejoindre un groupe.', 
        variant: 'destructive' 
      });
      return false;
    }

    if (loading) {
      console.log('‚è≥ Op√©ration d√©j√† en cours...');
      return false;
    }

    console.log('üé≤ D√©marrage joinRandomGroup pour:', user.id);
    setLoading(true);
    
    try {
      // V√©rifier les participations existantes
      const { data: existingParticipation, error: checkError } = await supabase
        .from('group_participants')
        .select('group_id, groups!inner(status)')
        .eq('user_id', user.id)
        .eq('status', 'confirmed')
        .in('groups.status', ['waiting', 'confirmed']);

      if (checkError) {
        console.error('‚ùå Erreur de v√©rification:', checkError);
        throw checkError;
      }

      if (existingParticipation && existingParticipation.length > 0) {
        console.log('‚ö†Ô∏è Utilisateur d√©j√† dans un groupe actif');
        toast({ 
          title: 'D√©j√† dans un groupe', 
          description: 'Vous √™tes d√©j√† dans un groupe actif !', 
          variant: 'destructive' 
        });
        return false;
      }

      let targetGroup: Group | null = null;

      // 1. Essayer de trouver un groupe compatible g√©ographiquement
      if (userLocation) {
        targetGroup = await findCompatibleGroup(userLocation);
      }

      // 2. Si pas de groupe g√©olocalis√© compatible, chercher un groupe classique
      if (!targetGroup) {
        const { data: waitingGroups, error: groupError } = await supabase
          .from('groups')
          .select('*')
          .eq('status', 'waiting')
          .lt('current_participants', 5)
          .order('created_at', { ascending: true })
          .limit(1);

        if (groupError) {
          console.error('‚ùå Erreur de recherche de groupes:', groupError);
          throw groupError;
        }

        if (waitingGroups && waitingGroups.length > 0) {
          targetGroup = waitingGroups[0] as Group;
          console.log('üîó Rejoindre le groupe existant:', targetGroup.id);
        }
      }

      // 3. Si toujours aucun groupe, cr√©er un nouveau groupe
      if (!targetGroup) {
        console.log('üÜï Cr√©ation d\'un nouveau groupe...');
        const newGroupData: any = {
          status: 'waiting',
          max_participants: 5,
          current_participants: 0
        };

        // Ajouter la g√©olocalisation si disponible
        if (userLocation) {
          newGroupData.latitude = userLocation.latitude;
          newGroupData.longitude = userLocation.longitude;
          newGroupData.location_name = userLocation.locationName;
          newGroupData.search_radius = 5000; // 5km par d√©faut
        }

        const { data: newGroup, error: createError } = await supabase
          .from('groups')
          .insert(newGroupData)
          .select()
          .single();

        if (createError) {
          console.error('‚ùå Erreur de cr√©ation de groupe:', createError);
          throw createError;
        }

        targetGroup = newGroup as Group;
        console.log('‚úÖ Nouveau groupe cr√©√©:', targetGroup.id);
      }

      // Ajouter l'utilisateur au groupe
      const participantData: any = {
        group_id: targetGroup.id,
        user_id: user.id,
        status: 'confirmed'
      };

      // Ajouter la g√©olocalisation du participant si disponible
      if (userLocation) {
        participantData.latitude = userLocation.latitude;
        participantData.longitude = userLocation.longitude;
        participantData.location_name = userLocation.locationName;
      }

      const { error: joinError } = await supabase
        .from('group_participants')
        .insert(participantData);

      if (joinError) {
        console.error('‚ùå Erreur d\'ajout au groupe:', joinError);
        throw joinError;
      }

      console.log('‚úÖ Utilisateur ajout√© au groupe avec succ√®s');

      // Mettre √† jour le nombre de participants
      const newParticipantCount = targetGroup.current_participants + 1;
      
      if (newParticipantCount >= 5) {
        const randomBar = getRandomBar(
          targetGroup.latitude || userLocation?.latitude,
          targetGroup.longitude || userLocation?.longitude
        );
        const meetingTime = new Date(Date.now() + 2 * 60 * 60 * 1000);
        
        await supabase
          .from('groups')
          .update({
            current_participants: newParticipantCount,
            status: 'confirmed',
            bar_name: randomBar.name,
            bar_address: randomBar.address,
            meeting_time: meetingTime.toISOString()
          })
          .eq('id', targetGroup.id);

        toast({ 
          title: 'üéâ Groupe complet !', 
          description: `Votre groupe de 5 est form√© ! Rendez-vous au ${randomBar.name} dans 2h.`,
        });
      } else {
        await supabase
          .from('groups')
          .update({ current_participants: newParticipantCount })
          .eq('id', targetGroup.id);

        const locationInfo = userLocation ? ` pr√®s de ${userLocation.locationName}` : '';
        toast({ 
          title: 'üöÄ Vous √™tes dans la course !', 
          description: `Groupe rejoint${locationInfo} ! En attente de ${5 - newParticipantCount} autre${5 - newParticipantCount > 1 ? 's' : ''} participant${5 - newParticipantCount > 1 ? 's' : ''}.`,
        });
      }

      // Attendre un peu avant de rafra√Æchir pour √©viter les conflits
      setTimeout(() => {
        fetchUserGroups();
      }, 500);
      
      return true;
    } catch (error) {
      console.error('‚ùå Erreur dans joinRandomGroup:', error);
      toast({ 
        title: 'Erreur', 
        description: 'Impossible de rejoindre un groupe. Veuillez r√©essayer.', 
        variant: 'destructive' 
      });
      return false;
    } finally {
      setLoading(false);
    }
  };

  const leaveGroup = async (groupId: string) => {
    if (!user || loading) {
      console.log('üö´ Impossible de quitter - pas d\'utilisateur ou chargement en cours');
      return;
    }

    setLoading(true);
    try {
      console.log('üö™ Quitter le groupe:', groupId, 'utilisateur:', user.id);

      // Supprimer la participation avec v√©rification explicite de l'utilisateur
      const { error: deleteError } = await supabase
        .from('group_participants')
        .delete()
        .eq('group_id', groupId)
        .eq('user_id', user.id)
        .eq('status', 'confirmed');

      if (deleteError) {
        console.error('‚ùå Erreur pour supprimer la participation:', deleteError);
        throw deleteError;
      }

      console.log('‚úÖ Participation supprim√©e');

      // Synchroniser le comptage apr√®s suppression
      await syncGroupParticipantCount(groupId);

      // V√©rifier s'il reste des participants
      const { data: remainingParticipants, error: checkError } = await supabase
        .from('group_participants')
        .select('id')
        .eq('group_id', groupId)
        .eq('status', 'confirmed');

      if (!checkError && remainingParticipants && remainingParticipants.length === 0) {
        // Supprimer le groupe s'il est vide
        console.log('üóëÔ∏è Suppression du groupe vide');
        await supabase
          .from('groups')
          .delete()
          .eq('id', groupId);
      } else if (!checkError && remainingParticipants && remainingParticipants.length < 5) {
        // Remettre le groupe en attente s'il y a moins de 5 participants
        console.log('‚è≥ Remise du groupe en attente');
        await supabase
          .from('groups')
          .update({
            status: 'waiting',
            bar_name: null,
            bar_address: null,
            meeting_time: null
          })
          .eq('id', groupId);
      }

      toast({ 
        title: '‚úÖ Groupe quitt√©', 
        description: 'Vous avez quitt√© le groupe avec succ√®s.' 
      });
      
      // Attendre un peu avant de rafra√Æchir
      setTimeout(() => {
        fetchUserGroups();
      }, 500);
    } catch (error) {
      console.error('‚ùå Erreur pour quitter le groupe:', error);
      toast({ 
        title: 'Erreur', 
        description: 'Impossible de quitter le groupe. Veuillez r√©essayer.', 
        variant: 'destructive' 
      });
    } finally {
      setLoading(false);
    }
  };

  // Effect pour charger les groupes au montage et quand l'utilisateur change
  useEffect(() => {
    if (user) {
      console.log('üîÑ Utilisateur d√©tect√©, chargement des groupes...');
      fetchUserGroups();
    } else {
      console.log('üö´ Pas d\'utilisateur, reset des groupes');
      setUserGroups([]);
    }
  }, [user?.id]); // Utiliser user.id plut√¥t que user pour √©viter les re-renders

  // ‚ûú Souscription en temps r√©el aux changements de participations utilisateur
  useEffect(() => {
    if (!user) return;

    // Incr√©menter le compteur d'abonn√©s
    subscriberCount++;
    console.log('üì° Nouveaux abonn√©s:', subscriberCount);

    // Cr√©er ou r√©utiliser le canal global
    if (!globalChannel) {
      console.log('üõ∞Ô∏è Cr√©ation du canal realtime global');
      globalChannel = supabase
        .channel('global-group-participants-changes')
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'group_participants',
          },
          (payload) => {
            console.log('üõ∞Ô∏è [Realtime] Changement d√©tect√© sur group_participants:', payload);
            // Rafra√Æchir les groupes pour tous les utilisateurs connect√©s
            fetchUserGroups();
          }
        )
        .subscribe();
    }

    return () => {
      // D√©cr√©menter le compteur d'abonn√©s
      subscriberCount--;
      console.log('üì° Abonn√©s restants:', subscriberCount);

      // Nettoyer le canal seulement quand il n'y a plus d'abonn√©s
      if (subscriberCount <= 0 && globalChannel) {
        console.log('üõ∞Ô∏è Fermeture du canal realtime global');
        supabase.removeChannel(globalChannel);
        globalChannel = null;
      }
    };
  }, [user?.id, fetchUserGroups]);

  return {
    groups,
    userGroups,
    loading,
    userLocation,
    joinRandomGroup,
    leaveGroup,
    fetchUserGroups
  };
};
